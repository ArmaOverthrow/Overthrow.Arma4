## Project Overview

Overthrow is a dynamic and persistent revolution mod for Arma Reforger. It's built using EnforceScript and the Enfusion engine's entity-component-based architecture.

## Important notes about EnforceScript
- Ternary operators are NOT supported, use fully-qualified if statements ALWAYS

## Development Workflow

Development is done through Arma Reforger Tools:
- You cannot compile/build the project, it must be done via the Arma Reforger Workbench. The user will do this and report any compile errors/debug prints etc to you
- There is no unit testing or integration testing available. Just old-skool play-testing. But be specific in what the user should do when testing new features or bugfixes

## Architecture Overview

### Class Patterns
#### Manager Components
Overthrow Manager components are singletons placed on the OVT_OverthrowGameMode.et prefab and tasked with management of a single system or feature within the game mode. Manager components should follow this pattern:

```cpp
class OVT_SomeManagerComponentClass: OVT_ComponentClass {};
class OVT_SomeManagerComponent: OVT_Component {
    [Attribute("1", desc: "A parameter description")]
    int m_iSomeParameter; //A parameter configurable in the Arma Reforger Tools
    
    static OVT_SomeManagerComponent s_Instance;
    static OVT_SomeManagerComponent GetInstance()
    {
      if (!s_Instance)
      {
        BaseGameMode pGameMode = GetGame().GetGameMode();
        if (pGameMode)
          s_Instance = OVT_SomeManagerComponent.Cast(pGameMode.FindComponent(OVT_SomeManagerComponent));
      }

      return s_Instance;
    }
    void Init(IEntity owner) { ... }
}
```
#### Controller Components
Controllers manage a single instance of an entity on the server (for example a base, a town, a camp etc), replication of the state of that instance to all clients, and persistence of that state if required in EPF. It is an `OVT_Component` extended component attached to an entity that is spawned at runtime or added to the world in the editor. These should NOT be singletons.

- Legacy controllers (base, town, etc) are detected by `QueryEntitiesBySphere` on startup or registered with their respective managers manually, but this method is now deprecated.
- Instead, in the controller component's constructor it should register itself with it's respective manager (both on client and server) as needed

```cpp
class OVT_SomeControllerComponentClass: OVT_ComponentClass {};
class OVT_SomeControllerComponent: OVT_Component 
{
    [Attribute("1", desc: "A parameter description")]
    protected int m_iSomeParameter; //A parameter configurable in the Arma Reforger Tools
    
    void Init(IEntity owner) { ... }
    //use getters and setters to expose parameters
    int GetSomeParameter() {return m_iSomeParameter;}
    void SetSomeParameter(int someParameter){m_iSomeParameter = someParameter;}
}
```

#### Other component classes
Don't make monolithic controllers, split their systems up as required with non-controller sub-components that manage a specific system on the same entity.

```cpp
class OVT_SomeComponentClass: OVT_ComponentClass {};
class OVT_SomeComponent: OVT_Component 
{
    [Attribute("1", desc: "A parameter description")]
    protected int m_iSomeParameter; //A parameter configurable in the Arma Reforger Tools
    
    void Init(IEntity owner) { ... }
    //use getters and setters to expose parameters
    int GetSomeParameter() {return m_iSomeParameter;}
    void SetSomeParameter(int someParameter){m_iSomeParameter = someParameter;}
}
```

Only components that are placed on entities (managers, controllers etc) require a corresponding `OVT_ComponentClass`.

#### Data structs
Simple data classes should extend `Managed`. These can be persisted easily if needed in EPF. They should not contain any [Attribute()] decorators. 

```cpp
class OVT_TownData : Managed
{
  [NonSerialized()]
	int nonSerializedInteger; //do not persist this to EPF

  vector location;
  int anInteger;
}
```

#### Garbage Collection and strong refs

Any reference to all of the above classes must be a strong ref to ensure they are only garbage collected when no references remain, otherwise they will be deleted at the end of frames. Always use "ref" keyword for arrays, maps and instances of Managed classes within arrays/maps
```cpp
class OVT_TownManagerComponent: OVT_Component
{
  ref OVT_TownData m_SelectedTown;
  ref array<ref OVT_TownData> m_Towns;
  ref map<int, ref OVT_TownData> m_mTowns;
}
```
You do not need to and cannot strong ref int, string, float, bool, IEntity or EntityID. Only class instances.

You can store an IEntity or arrays of IEntities but its usually best to store an EntityID instead and fetch it when needed and always check if the entity still exists:

```cpp
// Store the id
EntityID id = entity.GetID();

//Fetch it later
IEntity entity = GetGame().GetWorld().FindEntityByID(id);
if(!entity) return; //clean up anything you need to if the entity no longer exists
```

### Key entities and component types
- **OVT_OverthrowGameMode**: Central game mode entity coordinating all systems and managers + global events
- **OVT_OverthrowController**: Client-side entity for one to one client-server communication callbacks and events
- **Manager Components**: Manages entire systems and features, keeps track of controller instances, replicates and persists global state of systems
- **Controller Components**: Manages single instances of entities, replicates and persists state of these entities
- **Global Access**: `OVT_Global` provides static methods to access all managers

### Coding Conventions
- Class prefix: `OVT_`
- Member variables: `m_` prefix
- Type-specific prefixes: `m_a` (array), `m_m` (map), `m_i` (int), `m_f` (float), `m_s` (string), `m_b` (bool)
- Static instances: `s_Instance`
- Documentation: Doxygen style with `//!` comments
- Attributes: `[Attribute()]` for editor-exposed properties

### File Organization
- `Design/`: Design docs
- `Scripts/Game/Components/`: Entity components and UI components
- `Scripts/Game/GameMode/`: Core game logic and managers
- `Scripts/Game/Entities/`: Entity classes
- `Scripts/Game/Controllers/`: Controller components
- `Scripts/Game/Configuration/`: Config classes for game systems
- `Scripts/Game/UI/`: UI contexts and widgets
- `Scripts/Game/UserActions/`: Player interaction actions
- `Configs/`: Game configuration files
- `Prefabs/`: Entity prefabs and compositions

### Persistence
Components that require persistence need to define a SaveData class extending `EPF_ComponentSaveDataClass`:
```cpp
[EPF_ComponentSaveDataType(OVT_SomeManagerOrControllerComponent)]
class OVT_SomeSaveDataClass : EPF_ComponentSaveDataClass {};
class OVT_SomeSaveData : EPF_ComponentSaveData 
{
    void ReadFrom(OVT_SomeManagerOrControllerComponent component) { ... }
    void ApplyTo(OVT_SomeManagerOrControllerComponent component) { ... }
}
```

### Network Synchronization
- Components use RPC for multiplayer sync
- Rpl system handles replication
- Do not identify entities across the network using EntityIDs as these can be different between server/client. Instead use RplId and the Replication singleton to manage entities across the network.
- Manager components typically exist and operate only on the server and notify the client if needed
- Components (any class that extends OVT_Component) with data that needs to be replicated to clients must implement RplLoad and RplSave overrided methods to provide JIP (Join in progress) data streams to new joining players

#### Client-to-server
- A multiplayer client must be the "owner" of an entity with a component in order to ask the server to perform tasks
- `OVT_Global.GetServer()` is deprecated and should not be used anymore
- Instead, groups of server request types should be put in a component that is added to the `OVT_OverthrowController` entity that is assigned to each client on join
- Server requests should just accept tasks, delegate them to the required manager and track progress if needed
- If a progress bar for server requests is required, you can extend `OVT_BaseServerProgressComponent` and use similar patterns to `OVT_ContainerTransferComponent`. The UI will be handled automatically.

Pattern for calling a component on the Overthrow controller entity:
```cpp
//Get the locally controlled entity
OVT_OverthrowController controller = OVT_Global.GetController();
if(!controller) return; //we are on a dedicated server and therefore don't own a controller entity, fail silently

OVT_MyServerTaskComponent component = OVT_MyServerTaskComponent.Cast(controller.FindComponent(OVT_MyServerTaskComponent));
if(!component) return; //Entity is missing the required component, fail silently (it may be disabled for whatever reason)

component.MyTask(myParam); //component should RpcAsk and handle any response/callbacks as required
```

#### Global client-specific events
If a component on the `OVT_OverthrowController` component needs to invoke events available to other local components or entities on the client (such as UI events), you can add `ScriptInvoker` members to the controller entity. Use type-safety and wrap related events into a class if there are multiple needed. See `OVT_ProgressEventHandler` for an example.

#### RPC Pattern for Server Calls
When making RPC calls to server methods (RpcAsk_ methods), always check if the current instance is already the server to avoid unnecessary RPC overhead. The server can also be the host client:

```cpp
if(Replication.IsServer())
{
    RpcAsk_MethodName(params);  // Direct call if we're already on server
}else{
    Rpc(RpcAsk_MethodName, params);  // RPC call if we're on client
}
```

This pattern ensures that when the server is also the host client, we don't make an unnecessary RPC call to ourselves.

### User Interface
- Every player entity has a `OVT_UIManagerComponent` that handles UI context
- Any screen in Overthrow defines a context class extending `OVT_UIContext` and is registered with the UI Manager on the player prefab. The base class has a `ResourceName m_Layout` member property that defines a .layout file configured in the workbench and shown automatically when the context is activated.
- Example of activating a context to show a screen:

```cpp
OVT_UIManagerComponent ui = OVT_Global.GetUI();
if(!ui) return;

OVT_ShopContext context = OVT_ShopContext.Cast(ui.GetContext(OVT_ShopContext));
if(!context) return;

context.SetShop(shop);

ui.ShowContext(OVT_ShopContext);
```

### Important Notes
- Always use `OVT_Global.GetXXX()` to access manager instances
- Follow existing patterns when adding new components or systems

## External Dependencies

### Arma Reforger
- All base game scripts, configs and UI layouts can be found in: `/mnt/n/Projects/Arma 4/ArmaReforger`
- Always look here if you need to understand how something works in the game or accepted patterns for mod development

### EPF (Enfusion Persistence Framework)
- Location: `/mnt/n/Projects/Arma 4/EnfusionPersistenceFramework`
- Handles save/load operations and data persistence
- Console platforms (Xbox/PlayStation) don't support disk access - EPF must be disabled

### EDF (Enfusion Database Framework) 
- Location: `/mnt/n/Projects/Arma 4/EnfusionDatabaseFramework`
- Dependency of EPF for database operations

### Console Platform Handling
- Use `#ifdef PLATFORM_CONSOLE` for both Xbox and PlayStation (Arma Reforger only provides PLATFORM_CONSOLE and PLATFORM_WINDOWS)
- All FileIO operations and EPF persistence calls must be wrapped in PLATFORM_CONSOLE checks